<!--
Photo Selector Web App
Generated from spec v2.3.1 on 2025-11-16
Spec source: spec.md
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Photo Selector</title>
  <style>
    :root {
      /* JS will keep these in sync with CONFIG */
      --bgColor: #777;
      --cellPaddingPx: 8px;
      --gapPx: 8px;
      --cellBorderPx: 1px;
      --cellBorderColor: rgba(255,255,255,0.25);
      --uiGrayHigh: rgba(255,255,255,0.85);
      --uiGrayMid: rgba(255,255,255,0.55);
      --uiGrayLow: rgba(255,255,255,0.25);
      --controlSizePx: 40px;
      --controlInsetPx: 12px;
      --overlayPaddingPx: 16px;
      --focusTileBg: rgba(0,0,0,0.28);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bgColor);
      color: var(--uiGrayHigh);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      /* IMPORTANT: No grayscale filters anywhere; photos retain color */
      user-select: none; /* prevent accidental selection globally */
    }

    /* Allow selection where it makes sense */
    .allow-select { user-select: text; }

    /* Top bar */
    .topbar {
      position: sticky; top: 0; z-index: 50;
      display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
      padding: 8px; backdrop-filter: blur(4px);
      background: color-mix(in srgb, var(--bgColor) 80%, #000 20%);
      border-bottom: 1px solid var(--cellBorderColor);
    }
    .spacer { flex: 1; }
    .btn {
      appearance: none; border: 1px solid var(--cellBorderColor);
      background: transparent; color: var(--uiGrayHigh);
      padding: 6px 10px; border-radius: 8px; cursor: pointer;
      font: inherit; line-height: 1; display: inline-flex; align-items: center; gap: 6px;
    }
    .btn[aria-pressed="true"], .btn:focus-visible { outline: 2px solid var(--uiGrayHigh); outline-offset: 2px; }
    .btn:hover { background: color-mix(in srgb, var(--bgColor) 88%, #000 12%); }
    .count { white-space: nowrap; }

    /* Error banner */
    .banner { position: sticky; top: 48px; z-index: 40; margin: 0; padding: 8px 12px; background: #0006; color: var(--uiGrayHigh); border-block: 1px solid var(--cellBorderColor); }

    /* Grid */
    .grid {
      padding: var(--gapPx);
      display: grid;
      grid-template-columns: repeat(var(--cols, 3), 1fr);
      gap: var(--gapPx);
    }
    .cell { position: relative; aspect-ratio: 1/1; border: var(--cellBorderPx) solid var(--cellBorderColor); border-radius: 6px; overflow: hidden; background: #0002; }

    /* Each tile is a button */
    .tile { all: unset; display: grid; place-items: center; width: 100%; height: 100%; cursor: pointer; }
    .tile:focus-visible { outline: 2px solid var(--uiGrayHigh); outline-offset: 2px; background: var(--focusTileBg); }

    img.photo { width: 100%; height: 100%; object-fit: contain; -webkit-user-drag: none; user-drag: none; }

    /* selection box (corner) */
    .selbox { position: absolute; right: 6px; top: 6px; width: 22px; height: 22px; border-radius: 4px; border: 1px solid var(--uiGrayMid); background: #0006; display: grid; place-items: center; cursor: pointer; }
    .selbox:focus-visible { outline: 2px solid var(--uiGrayHigh); outline-offset: 2px; }
    .selbox::after { content: ""; width: 14px; height: 14px; box-shadow: inset 0 0 0 2px transparent; border-radius: 2px; border: 1px solid var(--uiGrayLow); }
    .selbox[aria-pressed="true"]::after { box-shadow: inset 0 0 0 2px var(--uiGrayHigh); }

    /* Spinner */
    .spinner { width: 24px; height: 24px; border: 2px solid var(--uiGrayLow); border-top-color: var(--uiGrayHigh); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Overlay */
    .overlay { position: fixed; inset: 0; z-index: 100; display: none; background: color-mix(in srgb, var(--bgColor) 70%, #000 30%); }
    .overlay[open] { display: grid; grid-template-rows: auto 1fr; }
    .overlay .chrome { display: flex; gap: 8px; align-items: center; padding: 8px; border-bottom: 1px solid var(--cellBorderColor); }
    .overlay .stage { position: relative; overflow: hidden; display: grid; place-items: center; padding: var(--overlayPaddingPx); touch-action: none; }
    .overlay .track { position: relative; width: 100%; height: calc(100% - 2*var(--overlayPaddingPx)); display: grid; grid-template-columns: 100% 100%; }
    .overlay .frame { position: absolute; inset: 0; display: grid; place-items: center; }
    .overlay .imgwrap { max-width: min(100%, var(--overlayMaxWidth, 100%)); max-height: 100%; }
    .overlay .imgwrap img { width: 100%; height: 100%; object-fit: contain; -webkit-user-drag: none; user-drag: none; }

    /* Overlay controls */
    .navbtn { position: absolute; top: 50%; transform: translateY(-50%); width: var(--controlSizePx); height: var(--controlSizePx); border-radius: 50%; display: grid; place-items: center; border: 1px solid var(--cellBorderColor); background: #0006; cursor: pointer; }
    .navbtn:focus-visible { outline: 2px solid var(--uiGrayHigh); }
    .prev { left: var(--controlInsetPx); }
    .next { right: var(--controlInsetPx); }

    .close { position: absolute; top: var(--controlInsetPx); right: var(--controlInsetPx); }

    /* Failure placeholder */
    .broken { width: 50%; aspect-ratio: 1/1; display: grid; place-items: center; border: 1px dashed var(--uiGrayLow); border-radius: 8px; color: var(--uiGrayMid); }

    /* High-contrast focus always visible */
    :focus-visible { outline: 2px solid var(--uiGrayHigh); outline-offset: 2px; }

    /* Filename row inside overlay (under top bar) */
    .filename-row { margin-left: 8px; color: var(--uiGrayMid); }

    /* Simple slide animation classes */
    .slide-enter { animation: slideIn var(--swipeMs, 220ms) ease both; }
    .slide-exit-left { animation: slideOutLeft var(--swipeMs, 220ms) ease both; }
    .slide-exit-right { animation: slideOutRight var(--swipeMs, 220ms) ease both; }
    @keyframes slideIn { from { transform: translateX(var(--fromX, 100%)); opacity: 0.7; } to { transform: translateX(0); opacity: 1; } }
    @keyframes slideOutLeft { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-20%); opacity: 0; } }
    @keyframes slideOutRight { from { transform: translateX(0); opacity: 1; } to { transform: translateX(20%); opacity: 0; } }
  </style>
</head>
<body>
  <div class="topbar" role="region" aria-label="Top bar">
    <div id="selCount" class="count" aria-live="polite">0 selected</div>
    <div class="spacer"></div>
    <button class="btn" id="shareOrCopy" aria-label="Share or copy link">Copy link</button>
    <button class="btn" id="copyNames" aria-label="Copy filenames" disabled>Copy filenames</button>
    <label class="btn" id="onlyWrap"><input type="checkbox" id="onlyChk" aria-label="Show only selected"> <span id="onlyLbl">Show only selected</span></label>
    <button class="btn" id="clearSel" aria-label="Clear selection" disabled>Clear</button>
    <button class="btn" id="toggleLang" aria-label="Toggle language">EN/SV</button>
  </div>
  <p id="banner" class="banner allow-select" hidden></p>

  <main>
    <div id="grid" class="grid" role="grid" aria-label="Photos grid"></div>
  </main>

  <!-- Overlay -->
  <section id="overlay" class="overlay" role="dialog" aria-modal="true" aria-label="Photo viewer" hidden>
    <div class="chrome">
      <button class="btn" id="ovClose" class="close" aria-label="Close" title="Esc">✕</button>
      <div class="filename-row allow-select" id="filenameRow"></div>
      <div class="spacer"></div>
      <button class="btn" id="ovCopyName" aria-label="Copy filename">Copy filename</button>
    </div>
    <div class="stage" id="ovStage">
      <button class="navbtn prev" id="ovPrev" aria-label="Previous" title="←">◀</button>
      <button class="navbtn next" id="ovNext" aria-label="Next" title="→">▶</button>
      <div class="frame" id="ovFrame"></div>
    </div>
  </section>

  <div id="live" class="sr-only" aria-live="polite"></div>

  <script>
    // === Configuration & Tunables (v2.3) ===
    const CONFIG = {
      baseDir: "photos/",
      approxCellSizePx: 180,
      cellPaddingPx: 8,
      gapPx: 8,
      bgColor: "#777",
      cellBorderPx: 1,
      cellBorderColor: "rgba(255,255,255,0.25)",
      uiGrayHigh: "rgba(255,255,255,0.85)",
      uiGrayMid:  "rgba(255,255,255,0.55)",
      uiGrayLow:  "rgba(255,255,255,0.25)",

      minColumns: 2,
      maxColumns: 12,
      rounding: "nearest", // nearest | floor | ceil

      gridMaxScale: 1.0,
      overlayMaxScale: 1.0,
      overlayPaddingPx: 16,
      controlSizePx: 40,
      controlInsetPx: 12,
      swipeAnimMs: 220,
      maxVisiblePreload: 2,

      selectionEnabled: true,
      showOnlySelectedDefault: false,
      filenameInOverlay: true,

      localeDefault: "en",

      focusTileBg: "rgba(0,0,0,0.28)",

      // Image manifest URL; expected schema: { images: ["IMG_0001.jpg", ...] }
      manifest: "manifest.json"
    };

    // UI strings (EN/SV)
    const STR = {
      en: {
        selected: n => `${n} photo${n===1?'':'s'} selected`,
        copyLink: "Copy link",
        share: "Share",
        copied: "Link copied",
        copyNames: "Copy filenames",
        copiedNames: "Filenames copied",
        only: "Show only selected",
        clear: "Clear",
        filenameCopy: "Copy filename",
        openUnknown: name => `Cannot open ‘${name}’ — not part of this gallery.`,
        selUnknown: list => `These images aren’t part of this gallery: ${list.join(', ')}`,
        dupes: list => `Blocking error: duplicate filenames in config: ${list.join(', ')}`,
        loadManifestFail: `Blocking error: couldn’t load image manifest. Ensure ${CONFIG.baseDir}${CONFIG.manifest} exists.`,
      },
      sv: {
        selected: n => `${n} bild${n===1?'':'er'} valda`,
        copyLink: "Kopiera länk",
        share: "Dela",
        copied: "Länk kopierad",
        copyNames: "Kopiera filnamn",
        copiedNames: "Filnamn kopierade",
        only: "Visa bara valda",
        clear: "Rensa",
        filenameCopy: "Kopiera filnamn",
        openUnknown: name => `Kan inte öppna ‘${name}’ — finns inte i detta galleri.`,
        selUnknown: list => `Dessa bilder ingår inte i galleriet: ${list.join(', ')}`,
        dupes: list => `Blockerande fel: dubbletter i konfigurationen: ${list.join(', ')}`,
        loadManifestFail: `Blockerande fel: kunde inte läsa manifestet. Se till att ${CONFIG.baseDir}${CONFIG.manifest} finns.`,
      }
    };

    // Apply CSS variables from CONFIG
    function applyTheme() {
      const r = document.documentElement.style;
      r.setProperty('--bgColor', CONFIG.bgColor);
      r.setProperty('--cellPaddingPx', CONFIG.cellPaddingPx + 'px');
      r.setProperty('--gapPx', CONFIG.gapPx + 'px');
      r.setProperty('--cellBorderPx', CONFIG.cellBorderPx + 'px');
      r.setProperty('--cellBorderColor', CONFIG.cellBorderColor);
      r.setProperty('--uiGrayHigh', CONFIG.uiGrayHigh);
      r.setProperty('--uiGrayMid', CONFIG.uiGrayMid);
      r.setProperty('--uiGrayLow', CONFIG.uiGrayLow);
      r.setProperty('--controlSizePx', CONFIG.controlSizePx + 'px');
      r.setProperty('--controlInsetPx', CONFIG.controlInsetPx + 'px');
      r.setProperty('--overlayPaddingPx', CONFIG.overlayPaddingPx + 'px');
      r.setProperty('--focusTileBg', CONFIG.focusTileBg);
      document.documentElement.style.setProperty('--swipeMs', CONFIG.swipeAnimMs + 'ms');
    }

    // Utilities
    const qs = sel => document.querySelector(sel);
    const qsa = sel => Array.from(document.querySelectorAll(sel));
    const $grid = () => qs('#grid');
    const $overlay = () => qs('#overlay');
    const $banner = () => qs('#banner');
    const $live = () => qs('#live');

    const debounce = (fn, ms=250) => { let t; return (...a)=>{ clearTimeout(t); t = setTimeout(()=>fn(...a), ms); }; };
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const hash = (str) => { let h = 0x811c9dc5; for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = (h>>>0) + ((h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24)); } return (h>>>0).toString(36); };
    const copyText = async (text) => { try { await navigator.clipboard.writeText(text); return true; } catch { return false; } };

    // State
    const state = {
      images: [], // filenames only
      imagesHash: '',
      selected: new Set(),
      only: !!CONFIG.showOnlySelectedDefault,
      open: null,
      lang: CONFIG.localeDefault,
      v: null,
    };

    // i18n helpers
    function L(key, ...args) {
      const dict = STR[state.lang] || STR[CONFIG.localeDefault];
      const val = dict[key];
      return typeof val === 'function' ? val(...args) : val;
    }
    function applyLangToUI(){
      const supportsShare = !!navigator.share;
      qs('#shareOrCopy').textContent = supportsShare ? L('share') : L('copyLink');
      qs('#copyNames').textContent = L('copyNames');
      qs('#onlyLbl').textContent = L('only');
      qs('#clearSel').textContent = L('clear');
      qs('#ovCopyName').textContent = L('filenameCopy');
      updateSelCount();
    }

    // Storage key
    const storageKey = () => `pg:${location.pathname}#${CONFIG.baseDir}#${state.imagesHash}`;

    // URL sync
    const parseURL = () => {
      const p = new URLSearchParams(location.search);
      return { sel: p.get('sel'), only: p.get('only') === '1', open: p.get('open'), lang: p.get('lang'), v: p.get('v') };
    };
    const pushURL = debounce(()=>{
      const p = new URLSearchParams(location.search);
      if (state.selected.size) p.set('sel', Array.from(state.selected).join(',')); else p.delete('sel');
      if (state.only) p.set('only','1'); else p.delete('only');
      if (state.open) p.set('open', state.open); else p.delete('open');
      if (state.lang) p.set('lang', state.lang); else p.delete('lang');
      if (state.v) p.set('v', state.v); else p.delete('v');
      history.replaceState(null, '', `${location.pathname}?${p.toString()}`);
      localStorage.setItem(storageKey(), JSON.stringify({ sel: Array.from(state.selected), only: state.only, open: state.open, lang: state.lang, v: state.v }));
    }, 200);

    // Banners
    function showBanner(msg){ const b=$banner(); b.textContent = msg; b.hidden = false; }
    function hideBanner(){ const b=$banner(); b.hidden = true; b.textContent = ''; }

    // Manifest loading & duplicate check
    async function loadImages(){
      try {
        const res = await fetch(CONFIG.baseDir + CONFIG.manifest, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const json = await res.json();
        const arr = Array.isArray(json?.images) ? json.images : [];
        state.images = arr.map(String).map(s=>s.split('/').pop());
        const seen = new Set(); const dupes=[];
        for (const f of state.images){ if (seen.has(f)) dupes.push(f); seen.add(f); }
        if (dupes.length){ showBanner(L('dupes', dupes)); throw new Error('dupes'); }
        state.imagesHash = hash(state.images.join('|'));
      } catch (e){ showBanner(L('loadManifestFail')); throw e; }
    }

    // Grid rendering
    function computeColumns(){
      const w = $grid().clientWidth || window.innerWidth;
      const approx = CONFIG.approxCellSizePx + CONFIG.gapPx;
      const raw = w / approx; let cols = raw;
      if (CONFIG.rounding === 'floor') cols = Math.floor(raw); else if (CONFIG.rounding==='ceil') cols = Math.ceil(raw); else cols = Math.round(raw);
      cols = Math.max(CONFIG.minColumns, Math.min(CONFIG.maxColumns, cols));
      $grid().style.setProperty('--cols', cols);
    }

    function makeCell(idx, filename){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.setAttribute('role','gridcell');
      cell.dataset.name = filename;

      const tile = document.createElement('button');
      tile.className = 'tile';
      tile.type = 'button';
      tile.tabIndex = 0;
      tile.addEventListener('click', ()=> openOverlay(filename));

      const img = document.createElement('img');
      img.className = 'photo'; img.alt = filename; img.loading = 'lazy'; img.decoding = 'async'; img.draggable = false;
      img.src = CONFIG.baseDir + filename;

      const sp = document.createElement('div'); sp.className = 'spinner';
      img.addEventListener('load', ()=> sp.remove());
      img.addEventListener('error', ()=>{ sp.remove(); const ph = document.createElement('div'); ph.className='broken'; ph.textContent='Load failed'; tile.appendChild(ph); });

      const sel = document.createElement('input');
      sel.type = 'checkbox';
      sel.className = 'selbox';
      sel.tabIndex = 0;
      sel.setAttribute('aria-label', `Select ${filename}`);
      sel.checked = state.selected.has(filename);
      sel.addEventListener('click', (e)=> e.stopPropagation());
      sel.addEventListener('change', ()=>{ toggleSelect(filename); sel.checked = state.selected.has(filename); });

      tile.appendChild(img); tile.appendChild(sp);
      cell.appendChild(tile); cell.appendChild(sel);
      return cell;
    }

    function renderGrid(){
      const g = $grid(); g.innerHTML = '';
      const list = state.only ? state.images.filter(n=>state.selected.has(n)) : state.images;
      list.forEach((name, i)=> g.appendChild(makeCell(i, name)));
      computeColumns();
    }

    function updateSelCount(){
      qs('#selCount').textContent = L('selected', state.selected.size);
      const hasSel = state.selected.size > 0;
      qs('#copyNames').disabled = !hasSel;
      qs('#clearSel').disabled = !hasSel;
    }

    // Selection
    function toggleSelect(filename){
      if (!CONFIG.selectionEnabled) return;
      if (state.selected.has(filename)) state.selected.delete(filename); else state.selected.add(filename);
      updateSelCount();
      $live().textContent = L('selected', state.selected.size);
      pushURL();
    }
    function clearSelection(){ state.selected.clear(); qsa('.selbox').forEach(b=>b.setAttribute('aria-pressed','false')); updateSelCount(); pushURL(); }

    // Overlay
    let touchStartX = null;
    function openOverlay(filename){
      if (!state.images.includes(filename)) { showBanner(L('openUnknown', filename)); return; }
      state.open = filename; pushURL();
      const ov = $overlay(); ov.hidden = false; ov.setAttribute('open','');
      document.body.style.overflow = 'hidden';
      qs('#filenameRow').textContent = CONFIG.filenameInOverlay ? filename : '';
      renderOverlayImage(filename, 0); // initial, no slide
      qs('#ovCopyName').onclick = ()=> copyText(filename).then(()=> $live().textContent = L('copiedNames'));
      setTimeout(()=> qs('#ovClose').focus(), 0);
    }
    function closeOverlay(){
      const ov = $overlay(); if (ov.hidden) return; ov.hidden = true; ov.removeAttribute('open');
      document.body.style.overflow = '';
      const prev = state.open; state.open = null; pushURL();
      const tile = qsa('.cell').find(c=>c.dataset.name===prev)?.querySelector('.tile');
      tile?.focus();
    }
    function idxOf(name){ return state.images.indexOf(name); }
    function step(delta){
      const i = idxOf(state.open); const j = Math.max(0, Math.min(state.images.length-1, i+delta));
      if (j !== i){ const dir = delta>0? 1 : -1; renderOverlayImage(state.images[j], dir); state.open = state.images[j]; pushURL(); }
    }
    function preloadAround(i){
      for (let d=-CONFIG.maxVisiblePreload; d<=CONFIG.maxVisiblePreload; d++){
        const j = i + d; if (j<0||j>=state.images.length) continue; const img = new Image(); img.src = CONFIG.baseDir + state.images[j];
      }
    }
    function renderOverlayImage(filename, dir){
      const frame = qs('#ovFrame');
      const old = frame.querySelector('img, .broken');

      const idx = idxOf(filename); preloadAround(idx);
      const holder = document.createElement('div'); holder.className = 'imgwrap';
      const img = new Image(); img.alt = filename; img.decoding='async'; img.src = CONFIG.baseDir + filename; img.draggable=false;

      const sp = document.createElement('div'); sp.className = 'spinner'; holder.appendChild(sp);
      img.addEventListener('load', ()=>{ holder.replaceChildren(img); });
      img.addEventListener('error', ()=>{ const ph = document.createElement('div'); ph.className='broken'; ph.textContent='Load failed'; holder.replaceChildren(ph); });

      // Animate: slide current out and new in
      if (old && dir){ old.classList.add(dir>0? 'slide-exit-left':'slide-exit-right'); }
      holder.classList.add('slide-enter');
      holder.style.setProperty('--fromX', dir>0? '100%':'-100%');
      frame.innerHTML = '';
      frame.appendChild(holder);
    }

    // Keyboard & focus navigation in grid
    function gridCells(){ return qsa('.grid .cell'); }

    // Arrow keys move between tiles (not affecting Tab order)
    $grid().addEventListener('keydown', (e)=>{
      const tiles = qsa('.grid .tile');
      const currentIndex = tiles.indexOf(document.activeElement);
      if (currentIndex === -1) return;
      const cols = parseInt(getComputedStyle($grid()).getPropertyValue('--cols')) || CONFIG.minColumns;
      let target = null;
      switch(e.key){
        case 'ArrowLeft': e.preventDefault(); target = Math.max(0, currentIndex-1); break;
        case 'ArrowRight': e.preventDefault(); target = Math.min(tiles.length-1, currentIndex+1); break;
        case 'ArrowUp': e.preventDefault(); target = Math.max(0, currentIndex - cols); break;
        case 'ArrowDown': e.preventDefault(); target = Math.min(tiles.length-1, currentIndex + cols); break;
        case 'Home': e.preventDefault(); target = Math.floor(currentIndex/cols)*cols; break;
        case 'End': e.preventDefault(); target = Math.min(tiles.length-1, Math.floor(currentIndex/cols)*cols + (cols-1)); break;
        case 'PageUp': e.preventDefault(); window.scrollBy({ top: -window.innerHeight*0.9, behavior: 'smooth' }); target = Math.max(0, currentIndex - cols); break;
        case 'PageDown': e.preventDefault(); window.scrollBy({ top: window.innerHeight*0.9, behavior: 'smooth' }); target = Math.min(tiles.length-1, currentIndex + cols); break;
        case 'Enter': case ' ': e.preventDefault(); document.activeElement.click(); return;
      }
      if (target!=null) tiles[target]?.focus();
    });

    // Overlay keys & interactions
    document.addEventListener('keydown', (e)=>{
      if ($overlay().hidden) return;
      if (e.key === 'Escape') { e.preventDefault(); closeOverlay(); }
      else if (e.key === 'ArrowLeft') { e.preventDefault(); step(-1); }
      else if (e.key === 'ArrowRight') { e.preventDefault(); step(1); }
      else if (e.key === ' ') { e.preventDefault(); toggleSelect(state.open); }
    });

    // Swipe (touch)
    let touchStart = null;
    qs('#ovStage').addEventListener('touchstart', (e)=>{ if (e.touches.length===1) touchStart = e.touches[0].clientX; }, {passive:true});
    qs('#ovStage').addEventListener('touchend', (e)=>{
      if (touchStart==null) return; const dx = (e.changedTouches[0].clientX - touchStart); touchStart=null; const thr = 30; if (dx > thr) step(-1); else if (dx < -thr) step(1);
    });

    // Backdrop click closes (ignore clicks on content or nav buttons)
    qs('#ovStage').addEventListener('click', (e)=>{
      const frame = qs('#ovFrame');
      if (!frame.contains(e.target)) closeOverlay();
    });

    // Persistence & tab sync
    function loadPersisted(){ try { const raw = localStorage.getItem(storageKey()); if (!raw) return null; return JSON.parse(raw); } catch { return null; } }
    window.addEventListener('storage', (e)=>{
      if (e.key !== storageKey()) return;
      try {
        const v = JSON.parse(e.newValue || '{}');
        state.selected = new Set(Array.isArray(v.sel)?v.sel:[]);
        state.only = !!v.only; state.open = v.open || null; state.lang = v.lang || state.lang; state.v = v.v || state.v;
        applyLangToUI(); renderGrid(); pushURL();
        if (state.open) openOverlay(state.open); else if (!$overlay().hidden) closeOverlay();
      } catch {}
    });

    // Controls
    function setupControls(){
      qs('#shareOrCopy').onclick = async ()=>{
        if (navigator.share) { try { await navigator.share({ url: location.href }); } catch {} }
        else { await copyText(location.href); $live().textContent = L('copied'); }
      }; $live().textContent = L('copied'); };
      qs('#copyNames').onclick = async ()=>{ const list = Array.from(state.selected); if (!list.length) return; const ok = await copyText(list.join('
')); $live().textContent = L('copiedNames'); };
      qs('#onlyChk').onchange = ()=>{ state.only = qs('#onlyChk').checked; renderGrid(); pushURL(); updateSelCount(); }; applyLangToUI(); renderGrid(); pushURL(); };
      qs('#clearSel').onclick = ()=>{ clearSelection(); };
      qs('#toggleLang').onclick = ()=>{ state.lang = (state.lang==='en'?'sv':'en'); applyLangToUI(); pushURL(); };

      qs('#ovPrev').onclick = ()=> step(-1);
      qs('#ovNext').onclick = ()=> step(1);
      qs('#ovClose').onclick = ()=> closeOverlay();

      window.addEventListener('resize', debounce(computeColumns, 50));
    }

    // URL & state initialization
    function initializeFromURL(){
      const p = parseURL();
      state.lang = p.lang || state.lang;
      state.only = p.only || state.only;
      state.v = p.v || state.v;
      const selParam = p.sel ? p.sel.split(',').filter(Boolean) : [];
      const unknownSel = selParam.filter(name=> !state.images.includes(name));
      if (selParam.length && unknownSel.length){ showBanner(L('selUnknown', unknownSel)); state.selected = new Set(); }
      else state.selected = new Set(selParam);
      if (p.open){ if (state.images.includes(p.open)) state.open = p.open; else showBanner(L('openUnknown', p.open)); }
    }

    function initializeFromStorage(){
      const v = loadPersisted(); if (!v) return;
      if (!location.search) { state.selected = new Set(Array.isArray(v.sel)?v.sel:[]); state.only = !!v.only; state.open = v.open || null; state.lang = v.lang || state.lang; state.v = v.v || state.v; }
    }

    // Boot
    (async function boot(){
      applyTheme();
      setupControls();
      await loadImages();
      initializeFromURL();
      if (!state.selected.size && !state.open) initializeFromStorage();
      applyLangToUI(); hideBanner(); renderGrid(); updateSelCount(); pushURL(); if (state.open) openOverlay(state.open);
    })();
  </script>
</body>
</html>
