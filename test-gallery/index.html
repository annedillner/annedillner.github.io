<!--
Photo Selector Web App
Generated from spec v2.2 on 2025-11-16
Spec source: spec.md
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Photo Selector</title>
  <style>
    :root {
      /* JS will keep these in sync with CONFIG */
      --bgColor: #777;
      --cellPaddingPx: 8px;
      --gapPx: 8px;
      --cellBorderPx: 1px;
      --cellBorderColor: rgba(255,255,255,0.25);
      --uiGrayHigh: rgba(255,255,255,0.85);
      --uiGrayMid: rgba(255,255,255,0.55);
      --uiGrayLow: rgba(255,255,255,0.25);
      --controlSizePx: 40px;
      --controlInsetPx: 12px;
      --overlayPaddingPx: 16px;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bgColor);
      color: var(--uiGrayHigh);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      filter: grayscale(100%);
    }

    /* Top bar */
    .topbar {
      position: sticky; top: 0; z-index: 50;
      display: flex; align-items: center; gap: 8px; flex-wrap: wrap;
      padding: 8px; backdrop-filter: blur(4px);
      background: color-mix(in srgb, var(--bgColor) 80%, #000 20%);
      border-bottom: 1px solid var(--cellBorderColor);
    }
    .spacer { flex: 1; }
    .btn {
      appearance: none; border: 1px solid var(--cellBorderColor);
      background: transparent; color: var(--uiGrayHigh);
      padding: 6px 10px; border-radius: 8px; cursor: pointer;
      font: inherit; line-height: 1; display: inline-flex; align-items: center; gap: 6px;
    }
    .btn[aria-pressed="true"], .btn:focus-visible { outline: 2px solid var(--uiGrayHigh); outline-offset: 2px; }
    .btn:hover { background: color-mix(in srgb, var(--bgColor) 88%, #000 12%); }
    .count { white-space: nowrap; }

    /* Error banner */
    .banner { position: sticky; top: 48px; z-index: 40; margin: 0; padding: 8px 12px; background: #0006; color: var(--uiGrayHigh); border-block: 1px solid var(--cellBorderColor); }

    /* Grid */
    .grid {
      padding: var(--gapPx);
      display: grid;
      grid-template-columns: repeat(var(--cols, 3), 1fr);
      gap: var(--gapPx);
    }
    .cell { position: relative; aspect-ratio: 1/1; border: var(--cellBorderPx) solid var(--cellBorderColor); border-radius: 6px; overflow: hidden; background: #0002; }
    .cell button.tile { all: unset; cursor: pointer; display: grid; place-items: center; width: 100%; height: 100%; }
    .cell img { width: 100%; height: 100%; object-fit: contain; }

    /* subtle checkmark */
    .mark { position: absolute; inset: 0; pointer-events: none; }
    .mark::after { content: ""; position: absolute; right: 6px; top: 6px; width: 18px; height: 18px; border-radius: 3px; border: 1px solid var(--uiGrayMid); background: #0004; box-shadow: inset 0 0 0 2px transparent; }
    .cell[aria-selected="true"] .mark::after { box-shadow: inset 0 0 0 2px var(--uiGrayHigh); }

    /* Spinner */
    .spinner { width: 24px; height: 24px; border: 2px solid var(--uiGrayLow); border-top-color: var(--uiGrayHigh); border-radius: 50%; animation: spin 1s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Overlay */
    .overlay { position: fixed; inset: 0; z-index: 100; display: none; background: color-mix(in srgb, var(--bgColor) 70%, #000 30%); }
    .overlay[open] { display: grid; grid-template-rows: auto 1fr; }
    .overlay .chrome { display: flex; gap: 8px; align-items: center; padding: 8px; border-bottom: 1px solid var(--cellBorderColor); }
    .overlay .stage { position: relative; overflow: hidden; display: grid; place-items: center; padding: var(--overlayPaddingPx); }
    .overlay .imgwrap { position: relative; max-width: min(100%, var(--overlayMaxWidth, 100%)); max-height: calc(100% - 2*var(--overlayPaddingPx)); }
    .overlay .imgwrap img { width: 100%; height: 100%; object-fit: contain; }

    /* Overlay controls */
    .navbtn { position: absolute; top: 50%; transform: translateY(-50%); width: var(--controlSizePx); height: var(--controlSizePx); border-radius: 50%; display: grid; place-items: center; border: 1px solid var(--cellBorderColor); background: #0006; cursor: pointer; }
    .navbtn:focus-visible { outline: 2px solid var(--uiGrayHigh); }
    .prev { left: var(--controlInsetPx); }
    .next { right: var(--controlInsetPx); }
    .close { position: absolute; top: var(--controlInsetPx); right: var(--controlInsetPx); }

    /* Failure placeholder */
    .broken { width: 50%; aspect-ratio: 1/1; display: grid; place-items: center; border: 1px dashed var(--uiGrayLow); border-radius: 8px; color: var(--uiGrayMid); }

    /* High-contrast focus always visible */
    :focus-visible { outline: 2px solid var(--uiGrayHigh); outline-offset: 2px; }

    /* Filename row inside overlay (under top bar) */
    .filename-row { margin-left: 8px; color: var(--uiGrayMid); }

    /* Utility */
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0, 0, 0, 0); white-space: nowrap; border: 0; }
  </style>
</head>
<body>
  <div class="topbar" role="region" aria-label="Top bar">
    <div id="selCount" class="count" aria-live="polite">0 selected</div>
    <div class="spacer"></div>
    <button class="btn" id="copyLink" aria-label="Copy link">Copy link</button>
    <button class="btn" id="copyNames" aria-label="Copy filenames">Copy filenames</button>
    <button class="btn" id="toggleOnly" aria-label="Show only selected" aria-pressed="false">Show only selected</button>
    <button class="btn" id="clearSel" aria-label="Clear selection">Clear</button>
    <button class="btn" id="toggleLang" aria-label="Toggle language">EN/SV</button>
  </div>
  <p id="banner" class="banner" hidden></p>

  <main>
    <div id="grid" class="grid" role="grid" aria-label="Photos grid"></div>
  </main>

  <!-- Overlay -->
  <section id="overlay" class="overlay" role="dialog" aria-modal="true" aria-label="Photo viewer" hidden>
    <div class="chrome">
      <button class="btn" id="ovClose" aria-label="Close" title="Esc">✕</button>
      <div class="filename-row" id="filenameRow"></div>
      <div class="spacer"></div>
      <button class="btn" id="ovCopyName" aria-label="Copy filename">Copy filename</button>
    </div>
    <div class="stage">
      <button class="navbtn prev" id="ovPrev" aria-label="Previous" title="←">◀</button>
      <button class="navbtn next" id="ovNext" aria-label="Next" title="→">▶</button>
      <div class="imgwrap" id="ovWrap"></div>
    </div>
  </section>

  <div id="live" class="sr-only" aria-live="polite"></div>

  <script>
    // === Configuration & Tunables (can be tweaked here; UI reads from here) ===
    const CONFIG = {
      baseDir: "photos/",
      approxCellSizePx: 180,
      cellPaddingPx: 8,
      gapPx: 8,
      bgColor: "#777",
      cellBorderPx: 1,
      cellBorderColor: "rgba(255,255,255,0.25)",
      uiGrayHigh: "rgba(255,255,255,0.85)",
      uiGrayMid:  "rgba(255,255,255,0.55)",
      uiGrayLow:  "rgba(255,255,255,0.25)",

      minColumns: 2,
      maxColumns: 12,
      rounding: "nearest", // nearest | floor | ceil

      gridMaxScale: 1.0,
      overlayMaxScale: 1.0,
      overlayPaddingPx: 16,
      controlSizePx: 40,
      controlInsetPx: 12,
      swipeAnimMs: 220,
      maxVisiblePreload: 2,

      selectionEnabled: true,
      showOnlySelectedDefault: false,
      filenameInOverlay: true,

      localeDefault: "en",

      // Image manifest URL; expected schema: { images: ["IMG_0001.jpg", ...] }
      manifest: "manifest.json"
    };

    // UI strings (EN/SV)
    const STR = {
      en: {
        selected: n => `${n} photo${n===1?'':'s'} selected`,
        copyLink: "Copy link",
        copied: "Link copied",
        copyNames: "Copy filenames",
        copiedNames: "Filenames copied",
        only: "Show only selected",
        onlyOn: "Showing only selected",
        clear: "Clear",
        filenameCopy: "Copy filename",
        openUnknown: name => `Cannot open ‘${name}’ — not part of this gallery.`,
        selUnknown: list => `These images aren’t part of this gallery: ${list.join(', ')}`,
        dupes: list => `Blocking error: duplicate filenames in config: ${list.join(', ')}`,
        loadManifestFail: `Blocking error: couldn’t load image manifest. Ensure ${CONFIG.baseDir}${CONFIG.manifest} exists.`,
      },
      sv: {
        selected: n => `${n} bild${n===1?'':'er'} valda`,
        copyLink: "Kopiera länk",
        copied: "Länk kopierad",
        copyNames: "Kopiera filnamn",
        copiedNames: "Filnamn kopierade",
        only: "Visa bara valda",
        onlyOn: "Visar bara valda",
        clear: "Rensa",
        filenameCopy: "Kopiera filnamn",
        openUnknown: name => `Kan inte öppna ‘${name}’ — finns inte i detta galleri.`,
        selUnknown: list => `Dessa bilder ingår inte i galleriet: ${list.join(', ')}`,
        dupes: list => `Blockerande fel: dubbletter i konfigurationen: ${list.join(', ')}`,
        loadManifestFail: `Blockerande fel: kunde inte läsa manifestet. Se till att ${CONFIG.baseDir}${CONFIG.manifest} finns.`,
      }
    };

    // Apply CSS variables from CONFIG
    function applyTheme() {
      const r = document.documentElement.style;
      r.setProperty('--bgColor', CONFIG.bgColor);
      r.setProperty('--cellPaddingPx', CONFIG.cellPaddingPx + 'px');
      r.setProperty('--gapPx', CONFIG.gapPx + 'px');
      r.setProperty('--cellBorderPx', CONFIG.cellBorderPx + 'px');
      r.setProperty('--cellBorderColor', CONFIG.cellBorderColor);
      r.setProperty('--uiGrayHigh', CONFIG.uiGrayHigh);
      r.setProperty('--uiGrayMid', CONFIG.uiGrayMid);
      r.setProperty('--uiGrayLow', CONFIG.uiGrayLow);
      r.setProperty('--controlSizePx', CONFIG.controlSizePx + 'px');
      r.setProperty('--controlInsetPx', CONFIG.controlInsetPx + 'px');
      r.setProperty('--overlayPaddingPx', CONFIG.overlayPaddingPx + 'px');
    }

    // Utilities
    const qs = sel => document.querySelector(sel);
    const qsa = sel => Array.from(document.querySelectorAll(sel));
    const $grid = () => qs('#grid');
    const $overlay = () => qs('#overlay');
    const $banner = () => qs('#banner');
    const $live = () => qs('#live');

    const debounce = (fn, ms=250) => { let t; return (...a)=>{ clearTimeout(t); t = setTimeout(()=>fn(...a), ms); }; };
    const clamp = (n, a, b) => Math.max(a, Math.min(b, n));
    const hash = (str) => {
      // simple 32-bit FNV-1a
      let h = 0x811c9dc5; for (let i=0;i<str.length;i++){ h ^= str.charCodeAt(i); h = (h>>>0) + ((h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24)); }
      return (h>>>0).toString(36);
    };
    const copyText = async (text) => {
      try { await navigator.clipboard.writeText(text); return true; } catch { return false; }
    };

    // State
    const state = {
      images: [], // filenames only
      imagesHash: '',
      selected: new Set(),
      only: !!CONFIG.showOnlySelectedDefault,
      open: null,
      lang: CONFIG.localeDefault,
      v: null,
      focusIdx: 0,
    };

    // i18n helpers
    function L(key, ...args) {
      const dict = STR[state.lang] || STR[CONFIG.localeDefault];
      const val = dict[key];
      return typeof val === 'function' ? val(...args) : val;
    }
    function applyLangToUI(){
      qs('#copyLink').textContent = L('copyLink');
      qs('#copyNames').textContent = L('copyNames');
      qs('#toggleOnly').textContent = state.only ? L('onlyOn') : L('only');
      qs('#clearSel').textContent = L('clear');
      qs('#ovCopyName').textContent = L('filenameCopy');
      updateSelCount();
    }

    // Storage key
    const storageKey = () => `pg:${location.pathname}#${CONFIG.baseDir}#${state.imagesHash}`;

    // URL sync
    const parseURL = () => {
      const p = new URLSearchParams(location.search);
      return {
        sel: p.get('sel'),
        only: p.get('only') === '1',
        open: p.get('open'),
        lang: p.get('lang'),
        v: p.get('v')
      };
    };
    const pushURL = debounce(()=>{
      const p = new URLSearchParams(location.search);
      if (state.selected.size) p.set('sel', Array.from(state.selected).join(',')); else p.delete('sel');
      if (state.only) p.set('only','1'); else p.delete('only');
      if (state.open) p.set('open', state.open); else p.delete('open');
      if (state.lang) p.set('lang', state.lang); else p.delete('lang');
      if (state.v) p.set('v', state.v); else p.delete('v');
      history.replaceState(null, '', `${location.pathname}?${p.toString()}`);
      // persist
      localStorage.setItem(storageKey(), JSON.stringify({
        sel: Array.from(state.selected), only: state.only, open: state.open, lang: state.lang, v: state.v
      }));
    }, 200);

    // Banners
    function showBanner(msg){ const b=$banner(); b.textContent = msg; b.hidden = false; }
    function hideBanner(){ const b=$banner(); b.hidden = true; b.textContent = ''; }

    // Manifest loading & duplicate check
    async function loadImages(){
      try {
        const res = await fetch(CONFIG.baseDir + CONFIG.manifest, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const json = await res.json();
        const arr = Array.isArray(json?.images) ? json.images : [];
        // normalize to filenames only (defensive)
        state.images = arr.map(String).map(s=>s.split('/').pop());
        // duplicates
        const seen = new Set(); const dupes=[];
        for (const f of state.images){ if (seen.has(f)) dupes.push(f); seen.add(f); }
        if (dupes.length){ showBanner(L('dupes', dupes)); throw new Error('dupes'); }
        state.imagesHash = hash(state.images.join('|'));
      } catch (e){ showBanner(L('loadManifestFail')); throw e; }
    }

    // Grid rendering
    function computeColumns(){
      const w = $grid().clientWidth || window.innerWidth;
      const approx = CONFIG.approxCellSizePx + CONFIG.gapPx;
      const raw = w / approx;
      let cols = raw;
      if (CONFIG.rounding === 'floor') cols = Math.floor(raw); else if (CONFIG.rounding==='ceil') cols = Math.ceil(raw); else cols = Math.round(raw);
      cols = clamp(cols, CONFIG.minColumns, CONFIG.maxColumns);
      $grid().style.setProperty('--cols', cols);
    }

    function makeCell(idx, filename){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.setAttribute('role','gridcell');
      cell.setAttribute('tabindex', idx===0 ? '0' : '-1');
      cell.dataset.idx = String(idx);
      cell.dataset.name = filename;
      cell.setAttribute('aria-selected', state.selected.has(filename));

      const btn = document.createElement('button');
      btn.className = 'tile';
      btn.addEventListener('click', (e)=>{ if (!CONFIG.selectionEnabled) return openOverlay(filename); toggleSelect(filename); });
      btn.addEventListener('dblclick', ()=> openOverlay(filename));

      const img = document.createElement('img');
      img.alt = filename;
      img.loading = 'lazy';
      img.decoding = 'async';
      img.src = CONFIG.baseDir + filename;
      const sp = document.createElement('div'); sp.className = 'spinner';
      img.addEventListener('load', ()=> sp.remove());
      img.addEventListener('error', ()=>{ sp.remove(); const ph = document.createElement('div'); ph.className='broken'; ph.textContent='Load failed'; btn.appendChild(ph); });

      const mark = document.createElement('div'); mark.className='mark';

      btn.appendChild(img); btn.appendChild(sp);
      cell.appendChild(btn); cell.appendChild(mark);
      return cell;
    }

    function renderGrid(){
      const g = $grid(); g.innerHTML = '';
      const list = state.only ? state.images.filter(n=>state.selected.has(n)) : state.images;
      list.forEach((name, i)=> g.appendChild(makeCell(i, name)));
      computeColumns();
    }

    function updateSelCount(){
      qs('#selCount').textContent = L('selected', state.selected.size);
      qs('#toggleOnly').textContent = state.only ? L('onlyOn') : L('only');
    }

    // Selection
    function toggleSelect(filename){
      if (!CONFIG.selectionEnabled) return;
      if (state.selected.has(filename)) state.selected.delete(filename); else state.selected.add(filename);
      const cell = qsa('.cell').find(c=>c.dataset.name===filename);
      if (cell) cell.setAttribute('aria-selected', state.selected.has(filename));
      updateSelCount();
      $live().textContent = L('selected', state.selected.size);
      pushURL();
    }

    function clearSelection(){ state.selected.clear(); qsa('.cell').forEach(c=>c.setAttribute('aria-selected','false')); updateSelCount(); pushURL(); }

    // Overlay
    let touchStartX = null;
    function openOverlay(filename){
      if (!state.images.includes(filename)) { showBanner(L('openUnknown', filename)); return; }
      state.open = filename; pushURL();
      const ov = $overlay(); ov.hidden = false; ov.setAttribute('open','');
      document.body.style.overflow = 'hidden';
      qs('#filenameRow').textContent = CONFIG.filenameInOverlay ? filename : '';
      renderOverlayImage(filename);
      qs('#ovCopyName').onclick = ()=> copyText(filename).then(()=> $live().textContent = L('copiedNames'));
      setTimeout(()=> qs('#ovClose').focus(), 0);
    }
    function closeOverlay(){
      const ov = $overlay(); ov.hidden = true; ov.removeAttribute('open');
      document.body.style.overflow = '';
      const prev = state.open; state.open = null; pushURL();
      // restore focus to grid cell
      const cell = qsa('.cell').find(c=>c.dataset.name===prev);
      if (cell) cell.focus();
    }
    function idxOf(name){ return state.images.indexOf(name); }
    function step(delta){
      const i = idxOf(state.open);
      const j = clamp(i + delta, 0, state.images.length-1);
      if (j !== i){ openOverlay(state.images[j]); }
    }
    function preloadAround(i){
      const to = new Set();
      for (let d=-CONFIG.maxVisiblePreload; d<=CONFIG.maxVisiblePreload; d++){
        const j = i + d; if (j<0||j>=state.images.length) continue; to.add(state.images[j]);
      }
      for (const name of to){ const img = new Image(); img.src = CONFIG.baseDir + name; }
    }
    function renderOverlayImage(filename){
      const wrap = qs('#ovWrap'); wrap.innerHTML = '';
      const idx = idxOf(filename);
      preloadAround(idx);
      const img = new Image(); img.alt = filename; img.decoding='async'; img.src = CONFIG.baseDir + filename;
      const sp = document.createElement('div'); sp.className = 'spinner';
      const holder = document.createElement('div'); holder.style.position='relative'; holder.appendChild(sp);
      img.addEventListener('load', ()=>{ holder.replaceChildren(img); });
      img.addEventListener('error', ()=>{ const ph = document.createElement('div'); ph.className='broken'; ph.textContent='Load failed'; holder.replaceChildren(ph); });
      wrap.appendChild(holder);
    }

    // Keyboard & focus navigation in grid
    function gridCells(){ return qsa('.grid .cell'); }
    function moveFocusGrid(currentIdx, deltaRow, deltaCol){
      const cells = gridCells(); const cols = parseInt(getComputedStyle($grid()).getPropertyValue('--cols')) || CONFIG.minColumns;
      let target = currentIdx + deltaRow*cols + deltaCol;
      target = clamp(target, 0, cells.length-1);
      cells.forEach((c,i)=> c.tabIndex = (i===target?0:-1));
      cells[target]?.focus();
    }

    // Persistence & tab sync
    function loadPersisted(){
      try {
        const raw = localStorage.getItem(storageKey()); if (!raw) return null; return JSON.parse(raw);
      } catch { return null; }
    }

    window.addEventListener('storage', (e)=>{
      if (e.key !== storageKey()) return;
      try {
        const v = JSON.parse(e.newValue || '{}');
        state.selected = new Set(Array.isArray(v.sel)?v.sel:[]);
        state.only = !!v.only; state.open = v.open || null; state.lang = v.lang || state.lang; state.v = v.v || state.v;
        applyLangToUI(); renderGrid(); pushURL();
        if (state.open) openOverlay(state.open); else if (!$overlay().hidden) closeOverlay();
      } catch {}
    });

    // Controls
    function setupControls(){
      qs('#copyLink').onclick = async ()=>{ const ok = await copyText(location.href); $live().textContent = L('copied'); };
      qs('#copyNames').onclick = async ()=>{ const list = Array.from(state.selected); if (!list.length) return; const ok = await copyText(list.join('\n')); $live().textContent = L('copiedNames'); };
      qs('#toggleOnly').onclick = ()=>{ state.only = !state.only; applyLangToUI(); renderGrid(); pushURL(); };
      qs('#clearSel').onclick = ()=>{ clearSelection(); };
      qs('#toggleLang').onclick = ()=>{ state.lang = (state.lang==='en'?'sv':'en'); applyLangToUI(); pushURL(); };

      // Overlay controls
      qs('#ovClose').onclick = ()=> closeOverlay();
      qs('#ovPrev').onclick = ()=> step(-1);
      qs('#ovNext').onclick = ()=> step(1);

      // Grid: clicks & keyboard
      $grid().addEventListener('keydown', (e)=>{
        const cells = gridCells();
        const current = document.activeElement.closest('.cell');
        const idx = current? Number(current.dataset.idx): 0;
        switch(e.key){
          case 'ArrowLeft': e.preventDefault(); moveFocusGrid(idx, 0, -1); break;
          case 'ArrowRight': e.preventDefault(); moveFocusGrid(idx, 0, 1); break;
          case 'ArrowUp': e.preventDefault(); moveFocusGrid(idx, -1, 0); break;
          case 'ArrowDown': e.preventDefault(); moveFocusGrid(idx, 1, 0); break;
          case 'Home': e.preventDefault(); moveFocusGrid(idx, 0, -9999); break;
          case 'End': e.preventDefault(); moveFocusGrid(idx, 0, 9999); break;
          case 'PageUp': e.preventDefault(); window.scrollBy({ top: -window.innerHeight*0.9, behavior: 'smooth' }); moveFocusGrid(idx, -1, 0); break;
          case 'PageDown': e.preventDefault(); window.scrollBy({ top: window.innerHeight*0.9, behavior: 'smooth' }); moveFocusGrid(idx, 1, 0); break;
          case 'Enter': e.preventDefault(); openOverlay(current?.dataset.name); break;
          case ' ': // Space toggles selection
            e.preventDefault(); if (current) toggleSelect(current.dataset.name); break;
        }
      });

      // Overlay keys
      document.addEventListener('keydown', (e)=>{
        if ($overlay().hidden) return;
        if (e.key === 'Escape') { e.preventDefault(); closeOverlay(); }
        else if (e.key === 'ArrowLeft') { e.preventDefault(); step(-1); }
        else if (e.key === 'ArrowRight') { e.preventDefault(); step(1); }
        else if (e.key === ' ') { e.preventDefault(); toggleSelect(state.open); }
      });

      // Swipe (touch)
      qs('#ovWrap').addEventListener('touchstart', (e)=>{ if (e.touches.length===1) touchStartX = e.touches[0].clientX; }, {passive:true});
      qs('#ovWrap').addEventListener('touchend', (e)=>{
        if (touchStartX==null) return; const dx = (e.changedTouches[0].clientX - touchStartX); touchStartX=null;
        const thr = 30; if (dx > thr) step(-1); else if (dx < -thr) step(1);
      });

      // Resize grid columns
      window.addEventListener('resize', debounce(computeColumns, 50));
    }

    // URL & state initialization
    function initializeFromURL(){
      const p = parseURL();
      state.lang = p.lang || state.lang;
      state.only = p.only || state.only;
      state.v = p.v || state.v;
      const selParam = p.sel ? p.sel.split(',').filter(Boolean) : [];
      const unknownSel = selParam.filter(name=> !state.images.includes(name));
      if (selParam.length && unknownSel.length){ showBanner(L('selUnknown', unknownSel)); state.selected = new Set(); }
      else state.selected = new Set(selParam);
      if (p.open){ if (state.images.includes(p.open)) state.open = p.open; else showBanner(L('openUnknown', p.open)); }
    }

    function initializeFromStorage(){
      const v = loadPersisted(); if (!v) return;
      if (!location.search) { // only if URL had no explicit intent
        state.selected = new Set(Array.isArray(v.sel)?v.sel:[]);
        state.only = !!v.only; state.open = v.open || null; state.lang = v.lang || state.lang; state.v = v.v || state.v;
      }
    }

    // Public helpers (link buttons)
    function copyLinkToClipboard(){ copyText(location.href).then(()=> $live().textContent=L('copied')); }

    // Boot
    (async function boot(){
      applyTheme();
      setupControls();
      await loadImages(); // may throw

      // compute images hash before storage key usage
      initializeFromURL();
      if (!state.selected.size && !state.open) initializeFromStorage();

      applyLangToUI();
      hideBanner(); // clear any older banners before validation messages below

      renderGrid();
      updateSelCount();
      pushURL();
      if (state.open) openOverlay(state.open);
    })();
  </script>
</body>
</html>
